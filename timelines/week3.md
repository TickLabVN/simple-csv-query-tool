# Week 3

In [week 2](week2.md), we took significant steps by implementing a simple CLI and validating and extracting data from `INSERT` statements.

Now, our journey progresses to a more intricate aspect of our language: handling `SELECT`` statements.

## Query tree: A Vital Structure

In our journey to process and understand queries more effectively, we introduced the concept of a **query tree**. This structured data representation serves as a bridge between the raw query and the eventual execution process. While our `INSERT` statement could be elegantly encapsulated using a simple C++ struct, the complexities of the `SELECT` statement necessitate a more sophisticated approach.

### Representing `INSERT` with a Struct

We saw that the data extracted from an `INSERT` statement could be neatly captured within a C++ struct:

```c++
struct InsertCommand {
    string filename;
    vector<string> columnNames;
    vector<string> values;
};
```

This straightforward structure aligns well with the simplicity of the INSERT statement.

### Challenges of Representing `SELECT`

However, the `SELECT` statement introduces a new set of challenges. Its syntax supports subqueries and multiple conditions, making it impossible to represent the query's structure using a predefined struct. For instance:

```sql
SELECT id, name, email
FROM (
    SELECT id, name, email, age
    FROM members.csv
    WHERE age > 22
)
WHERE name LIKE '%Vinh%' AND email LIKE '%@hcmut.edu.vn';
```

As seen in the above example, the structure of a `SELECT` query depends on how it's expressed, and it can involve subqueries and multiple logical conditions.

## Introducing the Query Tree

To tackle the complexities introduced by the SELECT statement, we adopt a more versatile approach: the query tree. This hierarchical structure allows us to represent the intricate relationships present in a query. The query tree helps us:

- **Organize Logic**: Hierarchically organize the various clauses, subqueries, conditions, and relationships in the query.
- **Understand Semantics**: Reflect the semantics of the query, ensuring that we correctly interpret the programmer's intentions.
- **Optimize Execution**: Serve as a foundation for query optimization, enabling us to choose the most efficient execution plan.

## Constructing the Query Tree

Constructing the query tree involves two main stages: tokenization using a lexer and syntactic analysis using a parser. These processes work together to break down the raw query into manageable tokens and understand their syntactic and semantic relationships.

- **Lexer (Tokenization)**: Transform the raw query string into a sequence of tokens, categorizing them by type and lexeme. These tokens form the basis for further analysis.
- **Parser (Syntactic Analysis)**: The parser processes the stream of tokens generated by the lexer. It constructs a structured representation of the query, often called a parse tree or syntax tree. The parser ensures that the token sequence adheres to the language's grammar rules.
- **Query Tree Construction**: The parse tree serves as a blueprint for building the query tree. This higher-level representation captures the query's semantics and removes unnecessary syntactic details.

By constructing and utilizing a query tree, we bridge the gap between a programmer's query and its execution. The tree provides a structured, semantically meaningful representation, essential for optimizing, understanding, and executing queries effectively.
